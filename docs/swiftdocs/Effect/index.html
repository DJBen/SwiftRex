<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwiftRex - Effect</title>
    <link rel="stylesheet" type="text/css" href="/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/">
            <strong>
                SwiftRex
            </strong>
            <span>Documentation</span>
        </a>
        <sup>Beta</sup>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#relationships">Relationships</a><ul><li><a href="#relationships">Conforms To</a></li></ul></li><li><a href="#nested type aliases">Nested Type Aliases</a><ul><li class="typealias"><a href="#effect.output">Output</a></li><li class="typealias"><a href="#effect.failure">Failure</a></li><li class="typealias"><a href="#effect.value">Value</a></li><li class="typealias"><a href="#effect.error">Error</a></li><li class="typealias"><a href="#effect.element">Element</a></li></ul></li><li><a href="#initializers">Initializers</a><ul><li class="initializer"><a href="#effect.init(upstream:)">init(upstream:​)</a></li><li class="initializer"><a href="#effect.init(upstream:cancellationtoken:)">init(upstream:​cancellation​Token:​)</a></li><li class="initializer"><a href="#effect.init(upstream:)">init(upstream:​)</a></li><li class="initializer"><a href="#effect.init(upstream:cancellationtoken:)">init(upstream:​cancellation​Token:​)</a></li><li class="initializer"><a href="#effect.init(upstream:)">init(upstream:​)</a></li><li class="initializer"><a href="#effect.init(upstream:cancellationtoken:)">init(upstream:​cancellation​Token:​)</a></li></ul></li><li><a href="#properties">Properties</a><ul><li class="property"><a href="#effect.cancellationtoken">cancellation​Token</a></li><li class="property"><a href="#effect.upstream">upstream</a></li><li class="property"><a href="#effect.donothing">do​Nothing</a></li><li class="property"><a href="#effect.cancellationtoken">cancellation​Token</a></li><li class="property"><a href="#effect.upstream">upstream</a></li><li class="property"><a href="#effect.producer">producer</a></li><li class="property"><a href="#effect.donothing">do​Nothing</a></li><li class="property"><a href="#effect.cancellationtoken">cancellation​Token</a></li><li class="property"><a href="#effect.upstream">upstream</a></li><li class="property"><a href="#effect.donothing">do​Nothing</a></li></ul></li><li><a href="#methods">Methods</a><ul><li class="method"><a href="#effect.receive(subscriber:)">receive(subscriber:​)</a></li><li class="method"><a href="#effect.cancellation(token:)">cancellation(token:​)</a></li><li class="method"><a href="#effect.just(_:from:)">just(_:​from:​)</a></li><li class="method"><a href="#effect.sequence(_:from:)">sequence(_:​from:​)</a></li><li class="method"><a href="#effect.sequence(_:from:)">sequence(_:​from:​)</a></li><li class="method"><a href="#effect.promise(_:)">promise(_:​)</a></li><li class="method"><a href="#effect.merge(_:_:)">merge(_:​_:​)</a></li><li class="method"><a href="#effect.merge(_:_:_:)">merge(_:​_:​_:​)</a></li><li class="method"><a href="#effect.merge(_:_:_:_:)">merge(_:​_:​_:​_:​)</a></li><li class="method"><a href="#effect.merge(_:_:_:_:_:)">merge(_:​_:​_:​_:​_:​)</a></li><li class="method"><a href="#effect.cancellation(token:)">cancellation(token:​)</a></li><li class="method"><a href="#effect.just(_:)">just(_:​)</a></li><li class="method"><a href="#effect.sequence(_:)">sequence(_:​)</a></li><li class="method"><a href="#effect.sequence(_:)">sequence(_:​)</a></li><li class="method"><a href="#effect.promise(_:)">promise(_:​)</a></li><li class="method"><a href="#effect.subscribe(_:)">subscribe(_:​)</a></li><li class="method"><a href="#effect.cancellation(token:)">cancellation(token:​)</a></li><li class="method"><a href="#effect.just(_:)">just(_:​)</a></li><li class="method"><a href="#effect.sequence(_:)">sequence(_:​)</a></li><li class="method"><a href="#effect.sequence(_:)">sequence(_:​)</a></li><li class="method"><a href="#effect.promise(_:)">promise(_:​)</a></li></ul></li></ol>
        </div>
    </nav>

    <main>
        <article>
            <h1>
    <small>Structure</small>
    <code class="name">Effect</code>
</h1>

<html><body><pre class="highlight"><code><span class="attribute">@</span><span class="attribute">available</span>(<span class="keyword">macOS</span> <span class="number literal">10.15</span>, <span class="keyword">iOS</span> <span class="number literal">13.0</span>, <span class="keyword">tvOS</span> <span class="number literal">13.0</span>, <span class="keyword">watchOS</span> <span class="number literal">6.0</span>, *) <span class="keyword">public</span> <span class="keyword">struct</span> <span class="type">Effect</span>&lt;<span class="variable">OutputAction</span>&gt;: <span class="type">Publisher</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p><code>Effect</code> is a Publisher/Observable/SignalProducer to be returned by Middlewares so they can dispatch Actions back to a Store. Every effect may
have a cancellation token to be later cancelled by new action arrivals, such as in the case when the user is no longer interested in certain HTTP
Request or wants to stop a timer. When cancellation token is not provided during the initialization of an Effect, it still can be passed later,
which will re-wrap the upstream again in a new Effect, but this time containing the cancellation token. Some static constructors are available,
such as <code>.doNothing</code>, <code>.just(_: Output)</code>, <code>.sequence(_: Output...)</code>, <code>.sequence(_: [Output]</code>, <code>.promise(_: CompletionHandler)</code>, etc.</p>

</div>
<div class="discussion">
    <p><code>Effect</code> is a stream of the type <code>EffectOutput</code>, which contains the action and the action source. Most of the times you want to create the
<code>EffectOutput</code> by simply calling <code>EffectOutput.dispatch(myAction)</code>, where myAction matches the <code>OutputActionType</code> of this middleware.</p>

<p>An Effect should never Fail, so any possible failure of its upstream must be caught and treated before the Effect is created. For example, if you
have an upstream that uses URLSession to fetch some data from an URL, once you get your data back you can dispatch a successful action. But in
case the task returns an URLError or some unexpected URLResponse, you should not fail, but instead, replace the error with an action to be
dispatched telling your store that the request has failed. This will enforce the usage of Actions as communication units between different
middlewares and reducers.</p>

<p>That's also the reason why <code>.asEffect()</code>, <code>.asEffect&lt;H: Hashable&gt;(cancellationToken: H)</code> and
<code>.asEffect&lt;H: Hashable&gt;(dispatcher: ActionSource, cancellationToken: H)</code> extensions are only available for publishers that have <code>Failure ==  Never</code>, when the reactive framework supports Failure constraints.</p>

<p>An Effect can be a single-shot sync or async, or a long-lasting one such as a timer. That's why cancellation token is so important. The option
<code>.doNothing</code> is an <code>Empty</code> publisher useful for when the middleware decides that certain conditions don't require any side-effect.</p>

</div>
<section id="relationships">
    <h2 hidden>Relationships</h2>
        <figure>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.0 (20200408.0750)
 -->
<!-- Pages: 1 -->
<svg width="872pt" height="116pt"
 viewBox="0.00 0.00 872.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-112 868,-112 868,4 -4,4"/>
<!-- Effect -->
<g id="node1" class="node structure current">
<title>Effect</title>
<g id="a_node1"><a xlink:href="/Effect" xlink:title="Effect">
<path fill="none" stroke="black" stroke-width="3" d="M528,-108C528,-108 336,-108 336,-108 330,-108 324,-102 324,-96 324,-96 324,-84 324,-84 324,-78 330,-72 336,-72 336,-72 528,-72 528,-72 534,-72 540,-78 540,-84 540,-84 540,-96 540,-96 540,-102 534,-108 528,-108"/>
<text text-anchor="middle" x="432" y="-86.3" font-family="Menlo" font-size="14.00">Effect</text>
</a>
</g>
</g>
<!-- Publisher -->
<g id="node2" class="node unknown">
<title>Publisher</title>
<path fill="none" stroke="black" d="M528,-36C528,-36 336,-36 336,-36 330,-36 324,-30 324,-24 324,-24 324,-12 324,-12 324,-6 330,0 336,0 336,0 528,0 528,0 534,0 540,-6 540,-12 540,-12 540,-24 540,-24 540,-30 534,-36 528,-36"/>
<text text-anchor="middle" x="432" y="-14.3" font-family="Menlo" font-size="14.00">Publisher</text>
</g>
<!-- Effect&#45;&gt;Publisher -->
<g id="edge1" class="edge conformsTo">
<title>Effect&#45;&gt;Publisher</title>
<path fill="none" stroke="black" d="M432,-71.7C432,-63.98 432,-54.71 432,-46.11"/>
<polygon fill="black" stroke="black" points="435.5,-46.1 432,-36.1 428.5,-46.1 435.5,-46.1"/>
</g>
</g>
</svg>


    <figcaption hidden>Inheritance graph for Effect.</figcaption>
</figure>
        <h3>Conforms To</h3>
<dl>
    <dt class="unknown"><code>ObservableType</code></dt>
<dt class="unknown"><code>Publisher</code></dt>
<dt class="unknown"><code>SignalProducerProtocol</code></dt>
</dl>
</section>
    <section id="nested type aliases">
        <h2>Nested Type Aliases</h2>

        <div role="article" class="typealias" id="effect.output">
    <h3>
        <code>Output</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="variable">Output</span> = <a href="/EffectOutput"><span class="type">EffectOutput</span></a>&lt;<span class="type">OutputAction</span>&gt;</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Output action matching middleware's <code>OutputActionType</code>, wrapped in a <code>EffectOutput&lt;OutputActionType&gt;</code> so the action dispatcher can also be
collected.</p>

</div>
</div>
<div role="article" class="typealias" id="effect.failure">
    <h3>
        <code>Failure</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="variable">Failure</span> = <span class="type">Never</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p><code>Effect</code> publisher/observable can't fail.</p>

</div>
</div>
<div role="article" class="typealias" id="effect.value">
    <h3>
        <code>Value</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="variable">Value</span> = <span class="type">OutputAction</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Output action matching middleware's <code>OutputActionType</code></p>

</div>
</div>
<div role="article" class="typealias" id="effect.error">
    <h3>
        <code>Error</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="variable">Error</span> = <span class="type">Never</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p><code>Effect</code> SignalProducer can't fail.</p>

</div>
</div>
<div role="article" class="typealias" id="effect.element">
    <h3>
        <code>Element</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="variable">Element</span> = <span class="type">OutputAction</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Element action matching middleware's <code>OutputActionType</code></p>

</div>
</div>
    </section>
    <section id="initializers">
        <h2>Initializers</h2>

        <div role="article" class="initializer" id="effect.init(upstream:)">
    <h3>
        <code>init(upstream:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">Publisher</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Output</span> == <span class="type">Output</span>, <span class="type">P</span>.<span class="type">Failure</span> == <span class="type">Failure</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream as long as it can't fail. Don't use eager publishers as upstream, such as Future, as they will unexpectedly
start the side-effect before the subscription.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream Publisher that can't fail and should not be eager.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="initializer" id="effect.init(upstream:cancellationtoken:)">
    <h3>
        <code>init(upstream:​cancellation​Token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">Publisher</span>, <span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>, <span class="variable">cancellationToken</span>: <span class="type">H</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Output</span> == <span class="type">Output</span>, <span class="type">P</span>.<span class="type">Failure</span> == <span class="type">Failure</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream as long as it can't fail. Don't use eager publishers as upstream, such as Future, as they will unexpectedly
start the side-effect before the subscription.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream Publisher that can't fail and should not be eager.</li>
</ul>
</td>
</tr>
<tr>
    <th>cancellation​Token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>cancellationToken: Cancellation token is any hashable used later to eventually cancel this effect before its completion. Once this effect is subscribed to, the subscription (in form of <code>AnyCancellable</code>) will be kept in a dictionary where the key is this cancellation token. If another effect with the same cancellation token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled. If you don't want this, not providing a cancellation token will only cancel your Effect in the very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated.  Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running effects, that way, the dictionary keeping the effects will cleanup the key with that token.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="initializer" id="effect.init(upstream:)">
    <h3>
        <code>init(upstream:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">SignalProducerProtocol</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Value</span> == <span class="type">Value</span>, <span class="type">P</span>.<span class="type">Error</span> == <span class="type">Never</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream as long as it can't fail.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream SignalProducerProtocol that can't fail.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="initializer" id="effect.init(upstream:cancellationtoken:)">
    <h3>
        <code>init(upstream:​cancellation​Token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">SignalProducerProtocol</span>, <span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>, <span class="variable">cancellationToken</span>: <span class="type">H</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Value</span> == <span class="type">Value</span>, <span class="type">P</span>.<span class="type">Error</span> == <span class="type">Never</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream as long as it can't fail.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream <code>SignalProducer</code> that can't fail.</li>
</ul>
</td>
</tr>
<tr>
    <th>cancellation​Token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>cancellationToken: Cancellation token is any hashable used later to eventually cancel this effect before its completion. Once this effect is subscribed to, the subscription (in form of <code>Lifetime.Token</code>) will be kept in a dictionary where the key is this cancellation token. If another effect with the same cancellation token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled. If you don't want this, not providing a cancellation token will only cancel your Effect in the very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated. Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running effects, that way, the dictionary keeping the effects will cleanup the key with that token.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="initializer" id="effect.init(upstream:)">
    <h3>
        <code>init(upstream:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">ObservableType</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Element</span> == <span class="type">Element</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream, please make sure it doesn't fail.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream Observable that shouldn't fail.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="initializer" id="effect.init(upstream:cancellationtoken:)">
    <h3>
        <code>init(upstream:​cancellation​Token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">ObservableType</span>, <span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">upstream</span>: <span class="type">P</span>, <span class="variable">cancellationToken</span>: <span class="type">H</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Element</span> == <span class="type">Element</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Create an effect with any upstream. Please be sure it neves fails.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>upstream</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>upstream: an upstream Observable. Please be sure it doesn't fail.</li>
</ul>
</td>
</tr>
<tr>
    <th>cancellation​Token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>cancellationToken: Cancellation token is any hashable used later to eventually cancel this effect before its completion. Once this effect is subscribed to, the subscription (in form of <code>DisposeBag</code>) will be kept in a dictionary where the key is this cancellation token. If another effect with the same cancellation token arrives, the former will be immediately disposed and replaced in the dictionary. If you don't want this, not providing a cancellation token will only cancel your Effect in the very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated. Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running effects, that way, the dictionary keeping the effects will cleanup the key with that token.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
    </section>
    <section id="properties">
        <h2>Properties</h2>

        <div role="article" class="variable" id="effect.cancellationtoken">
    <h3>
        <code>cancellation​Token</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">cancellationToken</span>: <span class="type">AnyHashable</span>?</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion. Once this effect is subscribed to, the
subscription (in form of <code>AnyCancellable</code>) will be kept in a dictionary where the key is this cancellation token. If another effect with the
same cancellation token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled.</p>

</div>
<div class="discussion">
    <p>If you don't want this, not providing a cancellation token will only cancel your Effect in the very unlike scenario where the
<code>EffectMiddleware</code> itself gets deallocated.</p>

<p>Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running effects, that way, the dictionary keeping
the effects will cleanup the key with that token.</p>

</div>
</div>
<div role="article" class="variable" id="effect.upstream">
    <h3>
        <code>upstream</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">upstream</span>: <span class="type">AnyPublisher</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;</code></pre></body></html>
</div>
<div role="article" class="variable" id="effect.donothing">
    <h3>
        <code>do​Nothing</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">doNothing</span>: <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An Empty effect that will complete immediately without emitting any output. Useful for when the Middleware doesn't want to perform any
side-effect.</p>

</div>
</div>
<div role="article" class="variable" id="effect.cancellationtoken">
    <h3>
        <code>cancellation​Token</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">cancellationToken</span>: <span class="type">AnyHashable</span>?</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion.
Once this effect is subscribed to, the subscription (in form of <code>Lifetime.Token</code>) will be kept in a
dictionary where the key is this cancellation token. If another effect with the same cancellation
token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled.</p>

</div>
<div class="discussion">
    <p>If you don't want this, not providing a cancellation token will only cancel your Effect in the
very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated.</p>

<p>Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running
effects, that way, the dictionary keeping the effects will cleanup the key with that token.</p>

</div>
</div>
<div role="article" class="variable" id="effect.upstream">
    <h3>
        <code>upstream</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">upstream</span>: <span class="type">SignalProducer</span>&lt;<span class="type">Value</span>, <span class="type">Never</span>&gt;</code></pre></body></html>
</div>
<div role="article" class="variable" id="effect.producer">
    <h3>
        <code>producer</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">producer</span>: <span class="type">SignalProducer</span>&lt;<span class="type">Value</span>, <span class="type">Never</span>&gt;</code></pre></body></html>
</div>
<div role="article" class="variable" id="effect.donothing">
    <h3>
        <code>do​Nothing</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">doNothing</span>: <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A <code>SignalProducer.empty</code> effect that will complete immediately without emitting any output. Useful for when
the Middleware doesn't want to perform any side-effect.</p>

</div>
</div>
<div role="article" class="variable" id="effect.cancellationtoken">
    <h3>
        <code>cancellation​Token</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">cancellationToken</span>: <span class="type">AnyHashable</span>?</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion.
Once this effect is subscribed to, the subscription (in form of <code>DisposeBag</code>) will be kept in a
dictionary where the key is this cancellation token. If another effect with the same cancellation
token arrives, the former will be immediately disposed and replaced in the dictionary.</p>

</div>
<div class="discussion">
    <p>If you don't want this, not providing a cancellation token will only cancel your Effect in the
very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated.</p>

<p>Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running
effects, that way, the dictionary keeping the effects will cleanup the key with that token.</p>

</div>
</div>
<div role="article" class="variable" id="effect.upstream">
    <h3>
        <code>upstream</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">upstream</span>: <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</code></pre></body></html>
</div>
<div role="article" class="variable" id="effect.donothing">
    <h3>
        <code>do​Nothing</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">doNothing</span>: <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An Empty effect that will complete immediately without emitting any output. Useful for when the Middleware
doesn't want to perform any side-effect.</p>

</div>
</div>
    </section>
    <section id="methods">
        <h2>Methods</h2>

        <div role="article" class="function" id="effect.receive(subscriber:)">
    <h3>
        <code>receive(subscriber:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">receive</span>&lt;<span class="variable">S</span>&gt;(<span class="variable">subscriber</span>: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Subscriber</span>, <span class="keyword">Self</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>, <span class="keyword">Self</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>This function is called to attach the specified <code>Subscriber</code> to this <code>Publisher</code> by <code>subscribe(_:)</code></p>

</div>
<div class="discussion">
    <aside class="seealso">
    <p><code>subscribe(_:)</code></p>

</aside>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>subscriber</th>
    <td><code class="type">S</code></td></td>
    <td><ul>
<li>subscriber: The subscriber to attach to this <code>Publisher</code>. Once attached it can begin to receive values.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="function" id="effect.cancellation(token:)">
    <h3>
        <code>cancellation(token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">cancellation</span>&lt;<span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">token</span>: <span class="type">H</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Adds a cancellation token to an Effect. This will re-wrap the upstream in a new Effect that also holds the cancellation token.</p>

</div>
<div class="discussion">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion. Once this effect is subscribed to, the
subscription (in form of <code>AnyCancellable</code>) will be kept in a dictionary where the key is this cancellation token. If another effect with the
same cancellation token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled.  If you don't want this,
not providing a cancellation token will only cancel your Effect in the very unlike scenario where the <code>EffectMiddleware</code> itself gets
deallocated.  Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running effects, that way, the
dictionary keeping the effects will cleanup the key with that token.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>token: any hashable you want.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>a new <code>Effect</code> instance, wrapping the upstream of original Effect but also holding the cancellation token.</p>

</div>
<div role="article" class="function" id="effect.just(_:from:)">
    <h3>
        <code>just(_:​from:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">just</span>(<span class="keyword">_</span> <span class="variable">value</span>: <span class="type">OutputAction</span>, <span class="variable">from</span> <span class="variable">dispatcher</span>: <a href="/ActionSource"><span class="type">ActionSource</span></a> = .<span class="variable">here</span>()) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a single value to be published before the completion.
It lifts a plain value into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>value</th>
    <td><code class="type">Output​Action</code></td></td>
    <td><ul>
<li>value: the one and only output to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
<tr>
    <th>dispatcher</th>
    <td><code class="type">Action​Source</code></td></td>
    <td><ul>
<li>dispatcher: The action source, so the Store and other middlewares know where this action is coming from. Default value is <code>ActionSource.here()</code>, referring to this line as the source. It can be customized for better logging results.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given value upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:from:)">
    <h3>
        <code>sequence(_:​from:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: <span class="type">OutputAction</span>, <span class="variable">from</span> <span class="variable">dispatcher</span>: <a href="/ActionSource"><span class="type">ActionSource</span></a> = .<span class="variable">here</span>()) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a sequence of values to be published before the completion.
It lifts a plain sequence of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">Output​Action</code></td></td>
    <td><ul>
<li>values: the sequence of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
<tr>
    <th>dispatcher</th>
    <td><code class="type">Action​Source</code></td></td>
    <td><ul>
<li>dispatcher: The action source, so the Store and other middlewares know where this action is coming from. Default value is <code>ActionSource.here()</code>, referring to this line as the source. It can be customized for better logging results.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:from:)">
    <h3>
        <code>sequence(_:​from:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: [<span class="type">OutputAction</span>], <span class="variable">from</span> <span class="variable">dispatcher</span>: <a href="/ActionSource"><span class="type">ActionSource</span></a> = .<span class="variable">here</span>()) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a sequence of values to be published before the completion.
It lifts a plain sequence of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">[Output​Action]</code></td></td>
    <td><ul>
<li>values: the sequence of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
<tr>
    <th>dispatcher</th>
    <td><code class="type">Action​Source</code></td></td>
    <td><ul>
<li>dispatcher: The action source, so the Store and other middlewares know where this action is coming from. Default value is <code>ActionSource.here()</code>, referring to this line as the source. It can be customized for better logging results.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.promise(_:)">
    <h3>
        <code>promise(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">promise</span>(<span class="keyword">_</span> <span class="variable">operation</span>: <span class="attribute">@</span><span class="attribute">escaping</span> ((<span class="type">Output</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An async task that will start upon subscription and needs to call a completion handler once when it's done.
You can create an Effect promise like this:</p>

</div>
<div class="discussion">
    <html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">String</span>&gt;.<span class="type">promise</span> { <span class="variable">completion</span> <span class="keyword">in</span>
    <span class="variable">doSomethingAsync</span> { <span class="variable">outputString</span> <span class="keyword">in</span>
        <span class="variable">completion</span>(<span class="variable">outputString</span>)
    }
}
</code></pre></body></html>
<p>Internally creates a <code>Deferred&lt;Future&lt;Output, Never&gt;&gt;</code></p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>operation</th>
    <td><code class="type">@escaping ((Output) -&gt; Void) -&gt; Void</code></td></td>
    <td><ul>
<li>operation: a closure that gives you a completion handler to be called once the async task is done</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will eventually publish the given output when you call the completion handler and that will only call your async task once it's subscribed by the Effect Middleware. Then, it will complete immediately as soon as it emits the first value.</p>

</div>
<div role="article" class="function" id="effect.merge(_:_:)">
    <h3>
        <code>merge(_:​_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>(<span class="keyword">_</span> <span class="variable">first</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">second</span>: <span class="type">Effect</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges multiple effects into one. This will result in an effect that will execute the given effects in parallel, with subscription starting
with the order provided but delivering output values in the order they arrive from any of the merged effects.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>first</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>first: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>second</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>second: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an Effect that will subscribe to all upstream effects provided above, and will combine their elements as they arrive.</p>

</div>
<div role="article" class="function" id="effect.merge(_:_:_:)">
    <h3>
        <code>merge(_:​_:​_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>(<span class="keyword">_</span> <span class="variable">first</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">second</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">third</span>: <span class="type">Effect</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges multiple effects into one. This will result in an effect that will execute the given effects in parallel, with subscription starting
with the order provided but delivering output values in the order they arrive from any of the merged effects.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>first</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>first: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>second</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>second: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>third</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>third: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an Effect that will subscribe to all upstream effects provided above, and will combine their elements as they arrive.</p>

</div>
<div role="article" class="function" id="effect.merge(_:_:_:_:)">
    <h3>
        <code>merge(_:​_:​_:​_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>(<span class="keyword">_</span> <span class="variable">first</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">second</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">third</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">fourth</span>: <span class="type">Effect</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges multiple effects into one. This will result in an effect that will execute the given effects in parallel, with subscription starting
with the order provided but delivering output values in the order they arrive from any of the merged effects.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>first</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>first: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>second</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>second: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>third</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>third: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>fourth</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>fourth: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an Effect that will subscribe to all upstream effects provided above, and will combine their elements as they arrive.</p>

</div>
<div role="article" class="function" id="effect.merge(_:_:_:_:_:)">
    <h3>
        <code>merge(_:​_:​_:​_:​_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>(<span class="keyword">_</span> <span class="variable">first</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">second</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">third</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">fourth</span>: <span class="type">Effect</span>, <span class="keyword">_</span> <span class="variable">fifth</span>: <span class="type">Effect</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges multiple effects into one. This will result in an effect that will execute the given effects in parallel, with subscription starting
with the order provided but delivering output values in the order they arrive from any of the merged effects.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>first</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>first: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>second</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>second: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>third</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>third: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>fourth</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>fourth: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
<tr>
    <th>fifth</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>fifth: any effect to have its elements merged into the final effect stream</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an Effect that will subscribe to all upstream effects provided above, and will combine their elements as they arrive.</p>

</div>
<div role="article" class="function" id="effect.cancellation(token:)">
    <h3>
        <code>cancellation(token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">cancellation</span>&lt;<span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">token</span>: <span class="type">H</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Adds a cancellation token to an Effect. This will rewrap the upstream in a new Effect that also holds the
cancellation token.</p>

</div>
<div class="discussion">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion.
Once this effect is subscribed to, the subscription (in form of <code>Lifetime.Token</code>) will be kept in a
dictionary where the key is this cancellation token. If another effect with the same cancellation
token arrives, the former will be immediately replaced in the dictionary and, therefore, cancelled.</p>

<p>If you don't want this, not providing a cancellation token will only cancel your Effect in the
very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated.</p>

<p>Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running
effects, that way, the dictionary keeping the effects will cleanup the key with that token.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>token: any hashable you want.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>a new <code>Effect</code> instance, wrapping the upstream of original Effect but also holding the cancellation token.</p>

</div>
<div role="article" class="function" id="effect.just(_:)">
    <h3>
        <code>just(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">just</span>(<span class="keyword">_</span> <span class="variable">value</span>: <span class="type">Value</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a single value to be published before the completion.
It lifts a plain value into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>value</th>
    <td><code class="type">Value</code></td></td>
    <td><ul>
<li>value: the one and only output to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given value upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:)">
    <h3>
        <code>sequence(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: <span class="type">Value</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a sequence of values to be published before the completion.
It lifts a plain sequence of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">Value</code></td></td>
    <td><ul>
<li>values: the sequence of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:)">
    <h3>
        <code>sequence(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: [<span class="type">Value</span>]) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps an Array of values to be published before the completion.
It lifts a plain Array of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">[Value]</code></td></td>
    <td><ul>
<li>values: the Array of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.promise(_:)">
    <h3>
        <code>promise(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">promise</span>(<span class="keyword">_</span> <span class="variable">operation</span>: <span class="attribute">@</span><span class="attribute">escaping</span> ((<span class="type">Value</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An async task that will start upon subscription and needs to call a completion handler once when it's done.
You can create an Effect promise like this:</p>

</div>
<div class="discussion">
    <html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">String</span>&gt;.<span class="type">promise</span> { <span class="variable">completion</span> <span class="keyword">in</span>
    <span class="keyword">let</span> <span class="variable">task</span> = <span class="variable">doSomethingAsync</span> { <span class="variable">outputString</span> <span class="keyword">in</span>
        <span class="variable">completion</span>(<span class="variable">outputString</span>)
    }
    <span class="keyword">return</span> <span class="variable">AnyDisposable</span>() <span class="comment">// Or a way to cancel the ongoing task</span>
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>operation</th>
    <td><code class="type">@escaping ((Value) -&gt; Void) -&gt; Disposable</code></td></td>
    <td><ul>
<li>operation: a closure that gives you a completion handler to be called once the async task is done, and returns a Disposable object that can be used for cancellation purposes</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will eventually publish the given output when you call the completion handler. and that will only call your async task once it's subscribed by the Effect Middleware. Then, it will complete immediately as soon as it emits the first value.</p>

</div>
<div role="article" class="function" id="effect.subscribe(_:)">
    <h3>
        <code>subscribe(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">subscribe</span>&lt;<span class="variable">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="keyword">_</span> <span class="variable">observer</span>: <span class="type">Observer</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">Observer</span>.<span class="type">Element</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Subscribes <code>observer</code> to receive events for this sequence.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>observer</th>
    <td><code class="type">Observer</code></td></td>
    <td><ul>
<li>observer: the counterpart willing to observe this observable for events and completion.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Subscription for <code>observer</code> that can be used to cancel production of sequence elements and free resources.</p>

</div>
<div role="article" class="function" id="effect.cancellation(token:)">
    <h3>
        <code>cancellation(token:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">cancellation</span>&lt;<span class="variable">H</span>: <span class="type">Hashable</span>&gt;(<span class="variable">token</span>: <span class="type">H</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Adds a cancellation token to an Effect. This will rewrap the upstream in a new Effect that also holds the
cancellation token.</p>

</div>
<div class="discussion">
    <p>Cancellation token is any hashable used later to eventually cancel this effect before its completion.
Once this effect is subscribed to, the subscription (in form of <code>DisposeBag</code>) will be kept in a
dictionary where the key is this cancellation token. If another effect with the same cancellation
token arrives, the former will be immediately disposed and replaced in the dictionary.</p>

<p>If you don't want this, not providing a cancellation token will only cancel your Effect in the
very unlike scenario where the <code>EffectMiddleware</code> itself gets deallocated.</p>

<p>Cancellation tokens can also be provided to the <code>EffectMiddleware</code> to force cancellation of running
effects, that way, the dictionary keeping the effects will cleanup the key with that token.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>token</th>
    <td><code class="type">H</code></td></td>
    <td><ul>
<li>token: any hashable you want.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>a new <code>Effect</code> instance, wrapping the upstream of original Effect but also holding the cancellation token.</p>

</div>
<div role="article" class="function" id="effect.just(_:)">
    <h3>
        <code>just(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">just</span>(<span class="keyword">_</span> <span class="variable">value</span>: <span class="type">Element</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a single value to be published before the completion.
It lifts a plain value into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>value</th>
    <td><code class="type">Element</code></td></td>
    <td><ul>
<li>value: the one and only output to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given value upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:)">
    <h3>
        <code>sequence(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: <span class="type">Element</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps a sequence of values to be published before the completion.
It lifts a plain sequence of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">Element</code></td></td>
    <td><ul>
<li>values: the sequence of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.sequence(_:)">
    <h3>
        <code>sequence(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">sequence</span>(<span class="keyword">_</span> <span class="variable">values</span>: [<span class="type">Element</span>]) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>A synchronous side-effect that just wraps an Array of values to be published before the completion.
It lifts a plain Array of values into an <code>Effect</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>values</th>
    <td><code class="type">[Element]</code></td></td>
    <td><ul>
<li>values: the Array of output values to be published, synchronously, before the effect completes.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will publish the given values upon subscription, and then complete, immediately.</p>

</div>
<div role="article" class="function" id="effect.promise(_:)">
    <h3>
        <code>promise(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">promise</span>(<span class="keyword">_</span> <span class="variable">operation</span>: <span class="attribute">@</span><span class="attribute">escaping</span> ((<span class="type">Element</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Effect</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An async task that will start upon subscription and needs to call a completion handler once when it's done.
You can create an Effect promise like this:</p>

</div>
<div class="discussion">
    <html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">String</span>&gt;.<span class="type">promise</span> { <span class="variable">completion</span> <span class="keyword">in</span>
    <span class="keyword">let</span> <span class="variable">task</span> = <span class="variable">doSomethingAsync</span> { <span class="variable">outputString</span> <span class="keyword">in</span>
        <span class="variable">completion</span>(<span class="variable">outputString</span>)
    }
    <span class="keyword">return</span> <span class="variable">Disposables</span>.<span class="type">create</span>() <span class="comment">// Or a way to cancel the ongoing task</span>
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>operation</th>
    <td><code class="type">@escaping ((Element) -&gt; Void) -&gt; Disposable</code></td></td>
    <td><ul>
<li>operation: a closure that gives you a completion handler to be called once the async task is done, and returns a Disposable object that can be used for cancellation purposes</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>an <code>Effect</code> that will eventually publish the given output when you call the completion handler. and that will only call your async task once it's subscribed by the Effect Middleware. Then, it will complete immediately as soon as it emits the first value.</p>

</div>
    </section>



        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2020-07-13T23:51:35+0200">13. July 2020</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-beta.3</span>.
</p>
    </footer>
</body>
</html>
